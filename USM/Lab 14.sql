-- QUESTION 1
-- THE MANAGEMENT WOULD LIKE TO HAVE A LIST OF BOOKS LOCATED AT BOTH LOCATIONS WITHOUT THE DUPLICATES.
-- ATTRIBUTES TO BE SHOWN IN THE LIST ARE ISBN, TITLE, CATEGORY AND COST. WRITE THE SQL STATEMENT. HOW MANY
-- RECORDS WILL BE IN THE LIST?
SELECT
    ISBN,
    TITLE,
    CATEGORY,
    COST
FROM
    BOOKS_IN_KL
UNION
SELECT
    ISBN,
    TITLE,
    CATEGORY,
    COST
FROM
    BOOKS_IN_PEN;

-- QUESTION 2
-- THE MANAGEMENT WOULD LIKE TO KNOW THE TOTAL NUMBER OF BOOKS LOCATED AT BOTH LOCATIONS (DUPLICATES
-- ARE ALLOWED). YOUR SQL STATEMENT MUST PRODUCE A DISPLAY AS FOLLOWS:
SELECT
    COUNT(*) AS TOTAL
FROM
    (
        SELECT
            *
        FROM
            BOOKS_IN_KL
        UNION
        ALL
        SELECT
            *
        FROM
            BOOKS_IN_PEN
    );            

-- QUESTION 3
-- THE MANAGEMENT WOULD LIKE TO KNOW THE STATISTICAL INFORMATION OF COST PRICE OF ALL THE DISTINCT BOOKS
-- LOCATED AT BOTH LOCATIONS. THESE INCLUDE MAXIMUM, MINIMUM, AVERAGE, STANDARD DEVIATION AND VARIANCE
-- OF THE COST PRICE. YOUR SQL STATEMENT MUST PRODUCE A DISPLAY AS FOLLOWS. PLEASE TAKE NOTE THAT THE
-- VALUES FOR AVERAGE, STANDARD DEVIATION AND VARIANCE MUST BE ROUNDED TO 4 DECIMAL PLACES.
SELECT
    MAX(COST)                AS MAX_COST,
    MIN(COST)                AS MIN_COST,
    ROUND(AVG(COST), 4)      AS AVG_COST,
    ROUND(VARIANCE(COST), 4) AS VARIANCE_COST,
    ROUND(STDDEV(COST), 4)   AS STDDEV_COST
FROM
    (
        SELECT
            ISBN,
            COST
        FROM
            BOOKS_IN_KL
        UNION
        SELECT
            ISBN,
            COST
        FROM
            BOOKS_IN_PEN
    );            

-- QUESTION 4
-- THE MANAGEMENT WOULD LIKE TO GET A LIST WHICH SHOWS THE COMMON BOOKS IN BOTH LOCATIONS. ALL COLUMNS
-- MUST BE INCLUDED IN THE DISPLAY LIST.
SELECT
    *
FROM
    BOOKS_IN_KL INTERSECT
    SELECT
        *
    FROM
        BOOKS_IN_PEN;

-- QUESTION 5
-- THE MANAGEMENT WOULD LIKE TO GET A LIST WHICH SHOWS THE BOOKS AT KUALA LUMPUR BRANCH BUT NOT
-- AVAILABLE AT THE PENANG BRANCH. ALL COLUMNS MUST BE INCLUDED IN THE DISPLAY LIST.
SELECT
    *
FROM
    BOOKS_IN_KL MINUS
    SELECT
        *
    FROM
        BOOKS_IN_PEN;

-- QUESTION 6
-- THE MANAGEMENT WOULD LIKE TO GET A LIST WHICH SHOWS THE BOOKS AT PENANG BRANCH BUT NOT AVAILABLE AT
-- THE KUALA LUMPUR BRANCH. ALL COLUMNS MUST BE INCLUDED IN THE DISPLAY LIST.
SELECT
    *
FROM
    BOOKS_IN_PEN MINUS
    SELECT
        *
    FROM
        BOOKS_IN_KL;

-- QUESTION 7
-- CREATE A TRIGGER WHICH DOES THE FOLLOWING: WHENEVER A RECORD IN THE BOOKS_IN_KL TABLE IS UPDATED OR
-- A NEW RECORD IS INSERTED, THE RET_PRICE WILL BE AUTO COMPUTED AS 5% MORE THAN THE COST PRICE. FOR
-- INSTANCE, A BOOK WITH COST PRICE OF $10.00 IS INSERTED;
-- THE RET_PRICE OF THAT BOOK WOULD BE $10.50
CREATE TRIGGER TRG_BOOKS_IN_KL ON BOOKS_IN_KL AFTER
    INSERT OR UPDATE OF COST ON BOOKS_IN_KL FOR EACH ROW AS
BEGIN
    UPDATE BOOKS_IN_KL
    SET
        RET_PRICE = NEW.COST * 1.05
    WHERE
        ISBN = NEW.ISBN;
END;

 -- Question8:
 -- How many rows will be listed when the following SQL command is executed?
 -- SELECT * FROM JOB CROSS JOIN EMPLOYEE;
11 (JOB) X 18 (EMPLOYEE) = 198 ROWS
 -- Question 9:
 -- By running the following SQL command,
 -- SELECT * FROM JOB, EMPLOYEE;
 -- similar results as of what have been produced by the SQL command
 -- in Question 8 can be generated.
 -- [TRUE/FALSE]
TRUE, BECAUSE THE COMMA IS EQUIVALENT TO CROSS JOIN
 -- Question 10:
 -- Produce the output based on the following SQL command.
 -- SELECT JOB_CODE, JOB_DESCRIPTION, EMP_LNAME
 -- FROM JOB NATURAL JOIN EMPLOYEE
 -- ORDER BY EMP_LNAME;
 -- Question 11:
 -- Produce the output based on the following SQL command.
 -- SELECT JOB_CODE, JOB_DESCRIPTION, EMP_LNAME
 -- FROM JOB JOIN EMPLOYEE USING(JOB_CODE)
 -- ORDER BY EMP_LNAME;
 -- Question 12:
 -- Produce the output based on the following SQL command.
 -- SELECT JOB_CODE, EMP_LNAME
 -- FROM JOB LEFT JOIN EMPLOYEE USING(JOB_CODE)
 -- ORDER BY EMP_LNAME;
 -- Question 13:
 -- Produce the output based on the following SQL command.
 -- SELECT JOB.JOB_CODE, EMP_LNAME
 -- FROM JOB LEFT JOIN EMPLOYEE ON JOB.JOB_CODE = EMPLOYEE.JOB_CODE
 -- ORDER BY EMP_LNAME;
 -- QUESTION 14:
 -- PRODUCE A LIST OF JOBS FROM THE JOB TABLE WHERE THE JOB_CHG_HOUR IS LESSER THAN THE OVERALL
 -- AVERAGE OF THE JOB_CHG_HOUR. THE ANTICIPATED OUTPUT IS SHOWN AS FOLLOWS:
SELECT
    JOB_CODE,
    JOB_DESCRIPTION,
    JOB_CHG_HOUR
FROM
    JOB
WHERE
    JOB_CHG_HOUR < (
        SELECT
            AVG(JOB_CHG_HOUR)
        FROM
            JOB
    );